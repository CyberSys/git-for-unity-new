<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Unity.Editor.Tasks</name>
    </assembly>
    <members>
        <member name="T:Unity.Editor.Tasks.ActionTask">
            <summary>
            A task that wraps an <see cref="T:System.Action" />-like method.
            The action can take no arguments;
            take a <see cref="T:System.Boolean" /> argument, with the success/failure value of the task that it depends on;
            or take <see cref="T:System.Boolean" /> and <see cref="T:System.Exception" /> arguments, with the success/failure value of the task that it depends on
            and any thrown exceptions from it.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ActionTask.#ctor(Unity.Editor.Tasks.ITaskManager,System.Action,System.Threading.CancellationToken)">
            <summary>
            Creates an instance of ActionTask.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
            <param name="action"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.ActionTask.#ctor(Unity.Editor.Tasks.ITaskManager,System.Action{System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of ActionTask.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
            <param name="action"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.ActionTask.#ctor(Unity.Editor.Tasks.ITaskManager,System.Action{System.Boolean,System.Exception},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of ActionTask.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
            <param name="action"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.ActionTask.Run(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ActionTask.Callback">
            <summary>
            The delegate called to invoke the action, in case the action doesn't care
            about thrown exceptions.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ActionTask.CallbackWithException">
            <summary>
            The delegate called to invoke the action, if the action cares about thrown
            exceptions.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ActionTask`1">
            <summary>
            A task that wraps an <see cref="T:System.Action`1" />-like method.
            The <typeparamref name="T"/> argument can be either the value of the previous task that this task depends on,
            or passed in via <see cref="F:Unity.Editor.Tasks.ActionTask`1.getPreviousResult" />,
            or passed in via <see cref="P:Unity.Editor.Tasks.ActionTask`1.PreviousResult" />
            The action can take one T argument;
            take a T and a <see cref="T:System.Boolean" /> argument, with the success/failure value of the task that it depends on;
            or take a T, a <see cref="T:System.Boolean" /> and <see cref="T:System.Exception" /> arguments, with the success/failure value of the task that it depends on
            and any thrown exceptions from it.
            </summary>
            <typeparam name="T">The type of the argument that the action is expecting</typeparam>
        </member>
        <member name="M:Unity.Editor.Tasks.ActionTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,System.Action{System.Boolean,`0},System.Func{`0},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of ActionTask.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
            <param name="action"></param>
            <param name="getPreviousResult">Method to call that returns the value that this task is going to work with. You can also use the PreviousResult property to set this value</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ActionTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,System.Action{System.Boolean,System.Exception,`0},System.Func{`0},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of ActionTask.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
            <param name="action"></param>
            <param name="getPreviousResult">Method to call that returns the value that this task is going to work with. You can also use the PreviousResult property to set this value</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ActionTask`1.RunSynchronously">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ActionTask`1.Run(System.Boolean,`0)">
            <summary>
            Runs the action, raises fault handlers and sets exceptions.
            This is the main body of an ITask.
            If you want to override this, make sure to
            follow the implementation pattern in order to properly propagate exceptions.
            </summary>
            <param name="success">The success value of the task this depends on, if any</param>
            <param name="previousResult">The value returned from the task this depends on, if any, or
            whatever was passed in via PreviousResult/getPreviousResult</param>
        </member>
        <member name="P:Unity.Editor.Tasks.ActionTask`1.Callback">
            <summary>
            The delegate called to invoke the action, in case the action doesn't care
            about thrown exceptions.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ActionTask`1.CallbackWithException">
            <summary>
            The delegate called to invoke the action, if the action cares about thrown
            exceptions.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ActionTask`1.PreviousResult">
            <summary>
            The result of the task this one depends on, if any, or manually set by the caller, if needed.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ActionTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,System.Action{`0},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of ActionTask<typeparamref name="T"/>.
            The delegate of the task will get the value that is returned from a previous task, if any, or from the <see cref="P:Unity.Editor.Tasks.ActionTask`1.PreviousResult"/> property,
            if set.
            </summary>
            <param name="taskManager"></param>
            <param name="action">A delegate thar receives a value of type T</param>
            <param name="token"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.ActionTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,System.Action{`0},System.Func{`0},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of ActionTask<typeparamref name="T"/>.
            The delegate of the task will get the value returned from the <paramref name="getPreviousResult"/> delegate.
            </summary>
            <param name="taskManager"></param>
            <param name="action">A delegate thar receives a value of type T</param>
            <param name="getPreviousResult">Method to call that returns the value that this task is going to work with.</param>
            <param name="token"></param>
        </member>
        <member name="T:Unity.Editor.Tasks.FuncTask`1">
            <summary>
            A task that wraps a <see cref="T:System.Func`1" />-like method.
            The action can take no arguments;
            take a <see cref="T:System.Boolean" /> argument, with the success/failure value of the task that it depends on;
            or take <see cref="T:System.Boolean" /> and <see cref="T:System.Exception" /> arguments, with the success/failure value of the task that it depends on
            and any thrown exceptions from it.
            </summary>
            <typeparam name="T">The type of the argument that the action returns</typeparam>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{`0},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of FuncTask.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
            <param name="action"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{System.Boolean,`0},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of FuncTask.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
            <param name="action"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{System.Boolean,System.Exception,`0},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of FuncTask.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
            <param name="action"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncTask`1.RunWithReturn(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.FuncTask`1.Callback">
            <summary>
            The delegate called to invoke the action, in case the action doesn't care
            about thrown exceptions.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.FuncTask`1.CallbackWithException">
            <summary>
            The delegate called to invoke the action, if the action cares about thrown
            exceptions.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.FuncTask`2">
            <summary>
            A task that wraps an <see cref="T:System.Func`2" />-like method.
            The <typeparamref name="T"/> argument can be either the value of the previous task that this task depends on,
            or passed in via <see cref="F:Unity.Editor.Tasks.TaskBase`2.getPreviousResult" />,
            or passed in via <see cref="P:Unity.Editor.Tasks.TaskBase`2.PreviousResult" />
            The action can take one T argument;
            take a T and a <see cref="T:System.Boolean" /> argument, with the success/failure value of the task that it depends on;
            or take a T, a <see cref="T:System.Boolean" /> and <see cref="T:System.Exception" /> arguments, with the success/failure value of the task that it depends on
            and any thrown exceptions from it.
            </summary>
            <typeparam name="T">The type of the argument that the action is expecting</typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncTask`2.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{System.Boolean,`0,`1},System.Func{`0},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of FuncTask.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
            <param name="action"></param>
            <param name="getPreviousResult"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncTask`2.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{System.Boolean,System.Exception,`0,`1},System.Func{`0},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of FuncTask.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
            <param name="action"></param>
            <param name="getPreviousResult"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncTask`2.RunWithData(System.Boolean,`0)">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.FuncTask`2.Callback">
            <summary>
            The delegate called to invoke the action, in case the action doesn't care
            about thrown exceptions.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.FuncTask`2.CallbackWithException">
            <summary>
            The delegate called to invoke the action, if the action cares about thrown
            exceptions.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncTask`2.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{`0,`1},System.Func{`0},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of FuncTask.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.FuncListTask`1">
            <summary>
            A task that wraps an Func&lt;T, List&lt;T&gt;&gt;-like method.
            </summary>
            <typeparam name="T">The type of the argument that the action is expecting and returns in a list.</typeparam>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{System.Boolean,System.Collections.Generic.List{`0}},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of FuncListTask.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
            <param name="action"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{System.Boolean,System.Exception,System.Collections.Generic.List{`0}},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of FuncListTask.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
            <param name="action"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{System.Boolean,Unity.Editor.Tasks.FuncListTask{`0},System.Collections.Generic.List{`0}},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of FuncListTask.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
            <param name="action"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncListTask`1.RunWithReturn(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.FuncListTask`1.Callback">
            <summary>
            The delegate called to invoke the action, in case the action doesn't care
            about thrown exceptions.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.FuncListTask`1.CallbackWithSelf">
            <summary>
            The delegate called to invoke the action, in case the action doesn't care
            about thrown exceptions.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.FuncListTask`1.CallbackWithException">
            <summary>
            The delegate called to invoke the action, if the action cares about thrown
            exceptions.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{System.Collections.Generic.List{`0}},System.Threading.CancellationToken)">
            <summary>
            
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.FuncListTask`3">
            <summary>
            A task that wraps an Func&lt;T, List&lt;TResult&gt;&gt;-like method.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TData"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncListTask`3.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{System.Boolean,`0,System.Collections.Generic.List{`2}},System.Func{`0},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of FuncListTask.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncListTask`3.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{System.Boolean,System.Exception,`0,System.Collections.Generic.List{`2}},System.Func{`0},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of FuncListTask.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncListTask`3.RunWithData(System.Boolean,`0)">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.FuncListTask`3.Callback">
            <summary>
            The delegate called to invoke the action, in case the action doesn't care
            about thrown exceptions.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.FuncListTask`3.CallbackWithException">
            <summary>
            The delegate called to invoke the action, if the action cares about thrown
            exceptions.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.FuncListTask`3.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{`0,System.Collections.Generic.List{`2}},System.Func{`0},System.Threading.CancellationToken)">
            <summary>
            
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.IProgress.Percentage">
            <summary>
            From 0 to 1
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.TaskAffinity">
            <summary>
            Thread affinity of a task.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskAffinity.Concurrent">
            <summary>
            Tasks with this affinity will only run when there are no Exclusive affinity tasks running.
            <see cref="M:Unity.Editor.Tasks.ITask.Then``1(``0,Unity.Editor.Tasks.TaskRunOptions,System.Boolean)" /> task handlers run with this affinity by default
            Reader side of the Writer-Reader pair of schedulers
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskAffinity.Exclusive">
            <summary>
            Tasks with this affinity will run one at a time, and no Concurrent affinity tasks will run at the same time as these
            Writer side of the Writer-Reader pair of schedulers
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskAffinity.UI">
            <summary>
            Tasks with this affinity will run on the UI thread (the thread that the task manager was initialized on
            TaskExtensions.ThenInUI and TaskExtensions.FinallyInUI task handlers run with this affinity by default
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskAffinity.Custom">
            <summary>
            Tasks with this affinity use a custom scheduler specified via <see cref="M:Unity.Editor.Tasks.TaskBase.InternalStart(System.Threading.Tasks.TaskScheduler)"/>
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskAffinity.None">
            <summary>
            Tasks with this affinity run in the thread pool. <see cref="M:Unity.Editor.Tasks.ITask.Finally(System.Action{System.Boolean,System.Exception},System.String,Unity.Editor.Tasks.TaskAffinity)" /> task handlers run with this affinity by default.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.TaskRunOptions">
            <summary>
            Sets where a task will run depending on the success/failure of the tasks it depends on.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskRunOptions.OnSuccess">
            <summary>
            Only run when previous tasks did not fail.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskRunOptions.OnFailure">
            <summary>
            Only run when previous tasks failed.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskRunOptions.OnAlways">
            <summary>
            Always run regardless of success/failure of previous tasks.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ITask">
            <summary>
            A task.
            </summary>
        </member>
        <member name="E:Unity.Editor.Tasks.ITask.OnStart">
            <summary>
            Raised when the task is starting. This is called on the same thread as the task.
            </summary>
        </member>
        <member name="E:Unity.Editor.Tasks.ITask.OnEnd">
            <summary>
            Raised when the task is finished, regardless of failure or success. This is called on the same thread as the task.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask.Then``1(``0,Unity.Editor.Tasks.TaskRunOptions,System.Boolean)">
            <summary>
            Append a task that will run when this task has finished running.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="continuation"></param>
            <param name="runOptions"></param>
            <param name="taskIsTopOfChain"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask.Catch(System.Action{System.Exception})">
            <summary>
            Handler called when a task fails.
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask.Catch(System.Func{System.Exception,System.Boolean})">
            <summary>
            Handler called when a task fails. This will run on the same thread as the task.
            If this handler returns true, the task becomes successful. Any exceptions supressed by this handler
            will still be available in the task object.
            </summary>
            <param name="handler"></param>
            <returns>True to supress this failure.</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask.FinallyInline(System.Action{System.Boolean})">
            <summary>
            Run a callback at the end of the task execution, on the same thread as the task that just finished, regardless of execution state
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask.Finally(System.Action{System.Boolean,System.Exception},System.String,Unity.Editor.Tasks.TaskAffinity)">
            <summary>
            Run a callback at the end of the task execution, on a separate thread, regardless of execution state
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask.Finally``1(``0)">
            <summary>
            Run another task at the end of the task execution, on a separate thread, regardless of execution state
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask.Start">
            <summary>
            Start a task.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask.Start(System.Threading.Tasks.TaskScheduler)">
            <summary>
            Start a task.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask.RunSynchronously">
            <summary>
            Executes the body of the task. This is called when tasks run, but if you want to run the task directly, you can call this.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask.Progress(System.Action{Unity.Editor.Tasks.IProgress})">
            <summary>
            Handler called with progress reporting for the task. This runs on the same thread as the task.
            </summary>
            <param name="progressHandler"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask.UpdateProgress(System.Int64,System.Int64,System.String)">
            <summary>
            Method called by tasks to update their progress.
            </summary>
            <param name="value"></param>
            <param name="total"></param>
            <param name="message"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask.GetTopOfChain(System.Boolean)">
            <summary>
            Get the task at the beginning of a chain of tasks.
            </summary>
            <param name="onlyCreated"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask.GetEndOfChain">
            <summary>
            Get the task at the end of a chain of tasks. This is a bit iffy, because tasks can be a tree with multiple endpoints.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask.IsChainExclusive">
            <summary>Checks whether any task on the chain is marked as exclusive.</summary>
            <returns>true if any task on the chain is marked as exclusive</returns>
        </member>
        <member name="P:Unity.Editor.Tasks.ITask.Successful">
            <summary>
            Was the task successful?
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ITask.Errors">
            <summary>
            Any errors the task set.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ITask.Task">
            <summary>
            The TPL task object, useful for direct awaiting.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ITask.Name">
            <summary>
            The name of this task, useful for logging.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ITask.Affinity">
            <summary>
            The task affinity.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ITask.Token">
            <summary>
            The cancellation token this task is listening to.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ITask.TaskManager">
            <summary>
            The task manager this task is attached to.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ITask.DependsOn">
            <summary>
            The task that this task depends on, if any.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ITask.Message">
            <summary>
            Error message.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ITask.Exception">
            <summary>
            Exceptions set by this task.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ITask`1">
            <summary>
            An ITask that returns a result.
            </summary>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="E:Unity.Editor.Tasks.ITask`1.OnStart">
            <summary>
            Raised when the task is starting.  Runs on the same thread as the task.
            </summary>
        </member>
        <member name="E:Unity.Editor.Tasks.ITask`1.OnEnd">
            <summary>
            Raised when the task is finished, regardless of failure. Runs on the same thread as the task.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask`1.Catch(System.Action{System.Exception})">
            <summary>
            Handler called when a task fails.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask`1.Catch(System.Func{System.Exception,System.Boolean})">
            <summary>
            Handler called when a task fails. This will run on the same thread as the task.
            If this handler returns true, the task becomes successful. Any exceptions supressed by this handler
            will still be available in the task object.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask`1.FinallyInline(System.Action{System.Boolean,`0})">
            <summary>
            Run a callback at the end of the task execution, on the same thread as the task that just finished, regardless of execution state
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask`1.Finally(System.Func{System.Boolean,System.Exception,`0,`0},System.String,Unity.Editor.Tasks.TaskAffinity)">
            <summary>
            Run a callback at the end of the task execution, on a separate thread, regardless of execution state
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask`1.Finally(System.Action{System.Boolean,System.Exception,`0},System.String,Unity.Editor.Tasks.TaskAffinity)">
            <summary>
            Run a callback at the end of the task execution, on a separate thread, regardless of execution state
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask`1.Start">
            <summary>
            Starts a task.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask`1.Start(System.Threading.Tasks.TaskScheduler)">
            <summary>
            Starts a task.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask`1.RunSynchronously">
            <summary>
            Executes the body of the task. This is called when tasks run, but if you want to run the task directly, you can call this.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ITask`1.Progress(System.Action{Unity.Editor.Tasks.IProgress})">
            <summary>
            Handler called with progress reporting for the task. This runs on the same thread as the task.
            </summary>
            <param name="progressHandler"></param>
            <returns></returns>
        </member>
        <member name="P:Unity.Editor.Tasks.ITask`1.Result">
            <summary>
            The result value of the task.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ITask`1.Task">
            <summary>
            The underlying TPL task object, useful for awaiting.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ITask`2">
            <summary>
            An ITask that raises an event whenever it creates data.
            </summary>
            <typeparam name="TData"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="E:Unity.Editor.Tasks.ITask`2.OnData">
            <summary>
            Raised when the task creates data.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.TaskBase">
            <summary>
            A task.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskBase.runAlwaysOptions">
            <summary>
            The TPL enums for running continuations that we rely on.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskBase.runOnSuccessOptions">
            <summary>
            The TPL enums for running continuations that we rely on.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskBase.runOnFaultOptions">
            <summary>
            The TPL enums for running continuations that we rely on.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskBase.Default">
            <summary>
            A default empty completed task.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskBase.continuationOnAlways">
            <summary>
            The continuation to schedule when this task is done.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskBase.continuationOnFailure">
            <summary>
            The continuation to schedule if this task fails.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskBase.continuationOnSuccess">
            <summary>
            The continuation to schedule if this task succeeds.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskBase.exceptionWasHandled">
            <summary>
            If this task failed but a catch handler suppressed the failure, this will be true.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskBase.taskFailed">
            <summary>
            If this task failed but a catch handler suppressed the failure, this will be true.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskBase.hasRun">
            <summary>
            Has this task run?
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskBase.previousException">
            <summary>
            If the previous task failed, this will have that exception.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskBase.previousSuccess">
            <summary>
            The previous task success value.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskBase.progress">
            <summary>
            This tasks's progress reporting object.
            </summary>
        </member>
        <member name="E:Unity.Editor.Tasks.TaskBase.OnStart">
            <inheritdoc />
        </member>
        <member name="E:Unity.Editor.Tasks.TaskBase.OnEnd">
            <inheritdoc />
        </member>
        <member name="E:Unity.Editor.Tasks.TaskBase.catchHandler">
            <summary>
            The catch handler, if any.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.#ctor">
            <summary>
            Empty constructor for default instances.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.#ctor(Unity.Editor.Tasks.ITaskManager,System.Threading.CancellationToken)">
            <summary>
            Creates an instance of TaskBase.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.Then``1(``0,Unity.Editor.Tasks.TaskRunOptions,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.Catch(System.Action{System.Exception})">
            <summary>
            Catch runs right when the exception happens (on the same thread)
            Chain will be cancelled
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.Catch(System.Func{System.Exception,System.Boolean})">
            <summary>
            Catch runs right when the exception happens (on the same threaD)
            Return true if you want the task to completely successfully
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.FinallyInline(System.Action{System.Boolean})">
            <summary>
            Run a callback at the end of the task execution, on the same thread as the task that just finished, regardless of execution state
            This will always run on the same thread as the previous task
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.Finally(System.Action{System.Boolean,System.Exception},System.String,Unity.Editor.Tasks.TaskAffinity)">
            <summary>
            Run a callback at the end of the task execution, on a separate thread, regardless of execution state
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.Finally``1(``0)">
            <summary>
            Run another task at the end of the task execution, on a separate thread, regardless of execution state
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.Progress(System.Action{Unity.Editor.Tasks.IProgress})">
            <summary>
            Progress provides progress reporting from the task (on the same thread)
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.Start">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.Start(System.Threading.Tasks.TaskScheduler)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.RunSynchronously">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.GetTopOfChain(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.GetEndOfChain">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.IsChainExclusive">
            <summary>Checks whether any task on the chain is marked as exclusive.</summary>
            <returns>true if any task on the chain is marked as exclusive</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.UpdateProgress(System.Int64,System.Int64,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.ToString">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.Schedule">
            <summary>
            Schedules this task on the task manager, if it hasn't been scheduled yet.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.Start(System.Threading.Tasks.Task)">
            <summary>
            Call this to run a task after another task is done, without
            having them depend on each other
            </summary>
            <param name="task"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.SetContinuation">
            <summary>
            Set the continuationOnAlways continuation with runAlwaysOptions, if there's one.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.SetContinuation(Unity.Editor.Tasks.TaskBase,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Set a continuation to run one this task is done.
            </summary>
            <param name="continuation"></param>
            <param name="runOptions"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.SetDependsOn(Unity.Editor.Tasks.ITask)">
            <summary>
            Set a task that this task depends on.
            </summary>
            <param name="dependsOn"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.GetTopMostStartableTask">
            <summary>
            Returns the first startable task on the chain. If the chain has been started
            already, returns null
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.GetTopMostCreatedTask">
            <summary>
            Returns the first task in a created state on the chain.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.GetTopMostTask">
            <summary>
            Returns the top most task of the chain.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.GetTopMostTask(Unity.Editor.Tasks.TaskBase,System.Boolean,System.Boolean)">
            <summary>
            Returns the top most task of the chain according to the parameters.
            </summary>
            <param name="ret"></param>
            <param name="onlyCreated"></param>
            <param name="onlyUnstartedChain"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.Run(System.Boolean)">
            <summary>
            Sets state prior to executing the body of a task. This runs in thread and is overridden
            by subclasses to actually execute the body of the task. It should be called before anything else.
            </summary>
            <param name="success"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.RaiseOnStart">
            <summary>
            Raises the OnStart event, setting the progress reporting object to 0.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.RaiseOnStartInternal">
            <summary>
            Raises the OnStart event.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.RaiseFaultHandlers(System.Exception)">
            <summary>
            Calls catch handlers and sets exception and message properties. This should be called in a Run
            override when a task fails, before throwing the exception. If this returns true, the task should not throw.
            </summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.RaiseOnEnd">
            <summary>
            Raises the OnEnd event, setting the progress reporting object to 100 and setting up continuations.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.RaiseOnEndInternal">
            <summary>
            Raises the OnEnd event.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.SetupContinuations">
            <summary>
            Set up continuations when the task is done. Also calls in-thread finally handlers.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.CallFinallyHandler">
            <summary>
            Calls any in-thread finally handlers.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.GetThrownException">
            <summary>
            Gets the exception that was thrown by the task or any tasks before it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase.SetFaultHandler(Unity.Editor.Tasks.TaskBase)">
            <summary>
            This does not set a dependency between the two tasks. Instead,
            the Start method grabs the state of the previous task to pass on
            to the next task via previousSuccess and previousException
            </summary>
            <param name="handler"></param>
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.Exception">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.Successful">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.IsCompleted">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.Errors">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.Task">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.AsyncWaitHandle">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.AsyncState">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.CompletedSynchronously">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.Name">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.Affinity">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.DependsOn">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.Token">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.TaskManager">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.TaskScheduler">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.Message">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase.Logger">
            <inheritdoc />
        </member>
        <member name="T:Unity.Editor.Tasks.TaskBase`1">
            <summary>
            A task returning a value.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.TaskBase`1.Default">
            <summary>
            A default empty completed task.
            </summary>
        </member>
        <member name="E:Unity.Editor.Tasks.TaskBase`1.OnStart">
            <inheritdoc />
        </member>
        <member name="E:Unity.Editor.Tasks.TaskBase`1.OnEnd">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.#ctor">
            <summary>
            Creates a TaskBase instance.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.#ctor(Unity.Editor.Tasks.ITaskManager,System.Threading.CancellationToken)">
            <summary>
            Creates a TaskBase instance.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.Then``1(``0,Unity.Editor.Tasks.TaskRunOptions,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.Catch(System.Action{System.Exception})">
            <summary>
            Catch runs right when the exception happens (on the same threaD)
            Marks the catch as handled so other Catch statements down the chain
            won't be called for this exception (but the chain will be cancelled)
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.Catch(System.Func{System.Exception,System.Boolean})">
            <summary>
            Catch runs right when the exception happens (on the same thread)
            Return false if you want other Catch statements on the chain to also
            get called for this exception
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.FinallyInline(System.Action{System.Boolean,`0})">
            <summary>
            Run a callback at the end of the task execution, on the same thread as the task that just finished, regardless of execution state
            This will always run on the same thread as the last task that runs
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.Finally(System.Func{System.Boolean,System.Exception,`0,`0},System.String,Unity.Editor.Tasks.TaskAffinity)">
            <summary>
            Run a callback at the end of the task execution, on a separate thread, regardless of execution state
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.Finally(System.Action{System.Boolean,System.Exception,`0},System.String,Unity.Editor.Tasks.TaskAffinity)">
            <summary>
            Run a callback at the end of the task execution, on a separate thread, regardless of execution state
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.Start">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.Start(System.Threading.Tasks.TaskScheduler)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.Progress(System.Action{Unity.Editor.Tasks.IProgress})">
            <summary>
            Progress provides progress reporting from the task (on the same thread)
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.RunSynchronously">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.RunWithReturn(System.Boolean)">
            <summary>
            Empty implementation of the base <see cref="M:Unity.Editor.Tasks.TaskBase.Run(System.Boolean)" /> method that
            returns the correct result type, so that implementations of this can follow
            the correct pattern (see example)
            </summary>
            <example><code lang="cs"><![CDATA[
            protected override TResult RunWithReturn(bool success)
            {
                var result = base.RunWithReturn(success);
                try
                {
                    if (Callback != null)
                    {
                        result = Callback(success);
                    }
                    else if (CallbackWithException != null)
                    {
                        var thrown = GetThrownException();
                        result = CallbackWithException(success, thrown);
                    }
                }
                catch (Exception ex)
                {
                    if (!RaiseFaultHandlers(ex))
                        Exception.Rethrow();
                }
                return result;
            }
            ]]></code></example>
            <param name="success"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.RaiseOnStart">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.RaiseOnEnd(`0)">
            <summary>
            Raises the OnEnd event, setting the progress reporting object to 100 and setting up continuations.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`1.CallFinallyHandler">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase`1.Task">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase`1.Result">
            <inheritdoc />
        </member>
        <member name="T:Unity.Editor.Tasks.TaskBase`2">
            <summary>
            A task that wraps an <see cref="T:System.Func`2" />-like method.
            The <typeparamref name="T"/> argument can be either the value of the previous task that this task depends on,
            or passed in via <see cref="F:Unity.Editor.Tasks.TaskBase`2.getPreviousResult" />,
            or passed in via <see cref="P:Unity.Editor.Tasks.TaskBase`2.PreviousResult" />
            </summary>
            <typeparam name="T">The type of the argument that the action is expecting</typeparam>
            <typeparam name="TResult">The type of the result the action returns.</typeparam>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`2.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{`0},System.Threading.CancellationToken)">
            <summary>
            Creates an instance of TaskBase.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
            <param name="getPreviousResult">Method to call that returns the value that this task is going to work with. You can also use the PreviousResult property to set this value</param>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`2.RunSynchronously">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskBase`2.RunWithData(System.Boolean,`0)">
            <summary>
            Empty implementation of the base <see cref="M:Unity.Editor.Tasks.TaskBase.Run(System.Boolean)" /> method that
            returns the correct result type, so that implementations of this can follow
            the correct pattern (see example)
            </summary>
            <example><code lang="cs"><![CDATA[
            protected override TResult RunWithData(bool success, T previousResult)
            {
                var result = base.RunWithData(success, previousResult);
                try
                {
                    if (Callback != null)
                    {
                        result = Callback(success, previousResult);
                    }
                    else if (CallbackWithException != null)
                    {
                        var thrown = GetThrownException();
                        result = CallbackWithException(success, thrown, previousResult);
                    }
                }
                catch (Exception ex)
                {
                    if (!RaiseFaultHandlers(ex))
                        Exception.Rethrow();
                }
                return result;
            }
            ]]></code></example>
            <param name="success"></param>
            <param name="previousResult"></param>
            <returns></returns>
        </member>
        <member name="P:Unity.Editor.Tasks.TaskBase`2.PreviousResult">
            <inheritdoc />
        </member>
        <member name="T:Unity.Editor.Tasks.DataTaskBase`2">
            <summary>
            A Task that raises events when it produces data, and that returns data.
            </summary>
            <typeparam name="TData"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="E:Unity.Editor.Tasks.DataTaskBase`2.OnData">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.DataTaskBase`2.#ctor(Unity.Editor.Tasks.ITaskManager,System.Threading.CancellationToken)">
             <summary>
            
             </summary>
             <param name="taskManager"></param>
             <param name="token"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.DataTaskBase`2.RaiseOnData(`0)">
            <summary>
            Raises the OnData event.
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:Unity.Editor.Tasks.DataTaskBase`3">
            <summary>
            A task that receives data, produces data, and returns data.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TData"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="E:Unity.Editor.Tasks.DataTaskBase`3.OnData">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.DataTaskBase`3.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{`0},System.Threading.CancellationToken)">
             <summary>
            
             </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.DataTaskBase`3.RaiseOnData(`1)">
            <summary>
            Raises the OnData event.
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:Unity.Editor.Tasks.TaskData">
            <summary>
            Stub task that can be used to update progress.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ITaskManager.Initialize">
            <summary>
            Call this from the main thread so task manager knows which thread is the main thread
            It uses the current synchronization context to queue tasks to the main thread
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ITaskManager.Initialize(System.Threading.SynchronizationContext)">
            <summary>
            Call this from a thread different from the the main thread. This will call
            synchronizationContext.Send() in order to set up the task manager on the
            thread of the synchronizationContext.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskManager.Initialize">
            <summary>
            Run this on the thread you would like to use as the main thread
            </summary>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskManager.Initialize(System.Threading.SynchronizationContext)">
            <summary>
            Run this on a thread different from the main thread represented by the
            synchronization context.
            </summary>
            <param name="synchronizationContext"></param>
            <returns></returns>
        </member>
        <member name="T:Unity.Editor.Tasks.TaskQueue">
            <summary>
            A class that can run multiple <see cref="T:Unity.Editor.Tasks.ITask" /> tasks concurrently. This task succeeds if
            all queued tasks succeed. If one or more queued tasks fail, this task fails, and the exception
            it returns is an aggregate of all the exceptions of the failed tasks.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskQueue.#ctor(Unity.Editor.Tasks.ITaskManager,System.Threading.CancellationToken)">
            <summary>
            Creates an instance of the TaskQueue.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskQueue.Queue(Unity.Editor.Tasks.ITask)">
            <summary>
            Adds a task to this TaskQueue.
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskQueue.RunSynchronously">
            <summary>
            Runs all the tasks and blocks until all tasks are finished. The tasks will
            run in their own threads according to their task affinity, so running this
            in a background thread won't deadlock.
            If this task queue's affinity is set for UI/Exclusive and any queued tasks are
            also on the same affinity, this will deadlock, so don't do that.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskQueue.Schedule">
            <inheritdoc />
        </member>
        <member name="T:Unity.Editor.Tasks.TaskQueue`2">
            <summary>
            A class that can run multiple <see cref="T:Unity.Editor.Tasks.ITask" /> tasks concurrently, and returns an aggregate
            of all the tasks results as a <see cref="T:System.Collections.Generic.List`1" />.
            The individual tasks that are queued to this TaskQueue must all return the same type <typeparam name="TTaskResult"/>,
            but the TaskQueue returns a list of <typeparam name="TResult" />. 
            To convert from <typeparamref name="TTaskResult"/> to <typeparamref name="TResult" />, pass in a converter in a constructor.
            This task succeeds if all queued tasks succeed.
            If one or more queued tasks fail, this task fails, and the exception it returns is an aggregate of all the exceptions of the failed tasks.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskQueue`2.#ctor(Unity.Editor.Tasks.ITaskManager,System.Func{Unity.Editor.Tasks.ITask{`0},`1},System.Threading.CancellationToken)">
            <summary>
            If <typeparamref name="TTaskResult"/> is not assignable to <typeparamref name="TResult"/>, you must pass a
            method to convert between the two. Implicit conversions don't count.
            </summary>
            <param name="token"></param>
            <param name="resultConverter"></param>
            <param name="taskManager"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskQueue`2.Queue(Unity.Editor.Tasks.ITask{`0})">
            <summary>
            Queues an ITask for running
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskQueue`2.RunSynchronously">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.TaskQueue`2.Schedule">
            <inheritdoc />
        </member>
        <member name="T:Unity.Editor.Tasks.TaskQueue`1">
            <summary>
            A class that can run multiple <see cref="T:Unity.Editor.Tasks.ITask" /> tasks concurrently, and returns a
            <see cref="T:System.Collections.Generic.List`1" /> with all the results of the individual tasks.
            The individual tasks that are queued to this TaskQueue must all return the same
            type.
            This task succeeds if all queued tasks succeed.
            If one or more queued tasks fail, this task fails, and the exception
            it returns is an aggregate of all the exceptions of the failed tasks.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskQueue`1.#ctor(Unity.Editor.Tasks.ITaskManager,System.Threading.CancellationToken)">
            <summary>
            
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.TPLTask.Initialize(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Call this if you're subclassing and haven't called one of the main public constructors
            </summary>
            <param name="theGetter"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.TPLTask.Initialize(System.Threading.Tasks.Task)">
            <summary>
            Call this if you're subclassing and haven't called one of the main public constructors
            </summary>
            <param name="theTask"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.TPLTask`1.Initialize(System.Func{System.Threading.Tasks.Task{`0}})">
            <summary>
            Call this if you're subclassing and haven't called one of the main public constructors
            </summary>
            <param name="theGetter"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.TPLTask`1.Initialize(System.Threading.Tasks.Task{`0})">
            <summary>
            Call this if you're subclassing and haven't called one of the main public constructors
            </summary>
            <param name="theTask"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.TPLTask`2.Initialize(System.Func{`0,System.Threading.Tasks.Task{`1}})">
            <summary>
            Call this if you're subclassing and haven't called one of the main public constructors
            </summary>
            <param name="theGetter"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.TPLTask`2.Initialize(System.Threading.Tasks.Task{`1})">
            <summary>
            Call this if you're subclassing and haven't called one of the main public constructors
            </summary>
            <param name="theTask"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.Extensions.StringExtensions.JoinForAppending(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Pretty much the same things as `String.Join` but used when appending to an already delimited string. If the values passed
            in are empty, it does not prepend the delimeter. Otherwise, it prepends with the delimiter.
            </summary>
            <param name="separator">The separator character</param>
            <param name="values">The set values to join</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ExceptionExtensions.IsCriticalException(System.Exception)">
            <summary>
            Represents exceptions we should never attempt to catch and ignore.
            </summary>
            <param name="exception">The exception being thrown.</param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ExceptionExtensions.IsFatalException(System.Exception)">
            <summary>
            Represents exceptions we should never attempt to catch and ignore when executing third party plugin code.
            This is not as extensive as a proposed IsCriticalException method that I want to write for our own code.
            </summary>
            <param name="exception">The exception being thrown.</param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTaskExtensions.Configure``1(``0,Unity.Editor.Tasks.IProcessManager,System.String)">
            <summary>
            Helper that calls processManager.Configure
            </summary>
            <typeparam name="T"></typeparam>
            <param name="task"></param>
            <param name="processManager"></param>
            <param name="workingDirectory"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskExtensions.FinallyInUI``1(``0,System.Action{System.Boolean,System.Exception},System.String)">
            <summary>
            A finally handler that will be called in the UI thread. Finally handlers are always called when any task fails in a chain. If there are multiple finally handlers,
            their call order is not deterministic.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="task"></param>
            <param name="continuation"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskExtensions.FinallyInUI``1(Unity.Editor.Tasks.ITask{``0},System.Action{System.Boolean,System.Exception,``0},System.String)">
            <summary>
            A finally handler that will be called in the UI thread. Finally handlers are always called when any task fails in a chain. If there are multiple finally handlers,
            their call order is not deterministic.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="task"></param>
            <param name="continuation"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskExtensions.StartAsAsync``1(Unity.Editor.Tasks.ITask{``0})">
            <summary>
            Helper that starts an <see cref="T:Unity.Editor.Tasks.ITask"/> and returns a <see cref="T:System.Threading.Tasks.Task"/>, capturing exceptions and results. If you
            want to await an <see cref="T:Unity.Editor.Tasks.ITask"/>, use this method.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskExtensions.StartAsAsync(Unity.Editor.Tasks.ITask)">
            <summary>
            Helper that starts an <see cref="T:Unity.Editor.Tasks.ITask"/> and returns a <see cref="T:System.Threading.Tasks.Task"/>, capturing exceptions. If you
            want to await an <see cref="T:Unity.Editor.Tasks.ITask"/>, use this method.
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskExtensions.StartSync``1(Unity.Editor.Tasks.ITask{``0},System.Threading.CancellationToken)">
            <summary>
            Starts a task, blocks until it's done or the token is cancelled, and returns the result;
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.TaskExtensions.ThenAsync(Unity.Editor.Tasks.ITask,System.Func{System.Threading.Tasks.Task},System.String)">
            		 * TPL Task section
            		*
        </member>
        <member name="M:Unity.Editor.Tasks.TaskExtensions.With(Unity.Editor.Tasks.ITaskManager,System.Action,System.String)">
            		 * With section
            		*
        </member>
        <member name="M:Unity.Editor.Tasks.TaskExtensions.WithAsync(Unity.Editor.Tasks.ITaskManager,System.Func{System.Threading.Tasks.Task},System.String)">
            		 * TPL Task section
            		*
        </member>
        <member name="M:Unity.Editor.Tasks.Helpers.Guard.EnsureNotNullOrWhiteSpace(System.String,System.String,System.String)">
            <summary>
              Checks a string argument to ensure it isn't null or empty.
            </summary>
            <param name = "value">The argument value to check.</param>
            <param name = "name">The name of the argument.</param>
            <param name="caller"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.Helpers.UriString.ToRepositoryUri">
            <summary>
            Attempts a best-effort to convert the remote origin to a GitHub Repository URL.
            </summary>
            <returns>A converted uri, or the existing one if we can't convert it (which might be null)</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.Helpers.UriString.ToRepositoryUrl">
            <summary>
            Attempts a best-effort to convert the remote origin to a GitHub Repository URL.
            </summary>
            <returns>A converted uri, or the existing one if we can't convert it (which might be null)</returns>
        </member>
        <member name="P:Unity.Editor.Tasks.Helpers.UriString.IsHypertextTransferProtocol">
            <summary>
            True if the URL is HTTP or HTTPS
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.Helpers.UriExtensions.Append(System.Uri,System.String)">
            <summary>
            Appends a relative path to the URL.
            </summary>
            <remarks>
            The Uri constructor for combining relative URLs have a different behavior with URLs that end with /
            than those that don't.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.Internal.IO.FileSystem.#ctor(System.String)">
            <summary>
            Initialize the filesystem object with the path passed in set as the current directory
            </summary>
            <param name="directory">Current directory</param>
        </member>
        <member name="T:Unity.Editor.Tasks.FirstNonNullOutputProcessor`1">
            <summary>
            Returns the first non-null, non-empty (after trim) input.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Unity.Editor.Tasks.FirstResultOutputProcessor`1">
            <summary>
            Processor that returns one output of type <typeparamref name="T"/>
            from one or more string inputs. <see cref="M:Unity.Editor.Tasks.BaseOutputProcessor`1.RaiseOnEntry(`0)"/>
            will only be called once on this processor.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Unity.Editor.Tasks.FirstResultOutputProcessor`1.#ctor(System.Func{System.String,`0})">
            <summary>
            The first input that the converter can convert without throwing an exception will
            be the result of this output processor, all other inputs are ignored.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.FirstResultOutputProcessor`1.#ctor(Unity.Editor.Tasks.BaseOutputProcessor{`0}.FuncO{System.String,`0,System.Boolean})">
            <summary>
            The first input that the <paramref name="handler"/> returns true will be
            the result of this output processor, all other inputs will be ignored.
            </summary>
            <param name="handler"></param>
        </member>
        <member name="T:Unity.Editor.Tasks.RaiseAndDiscardOutputProcessor">
            <summary>
            Takes a string, raises an event with it, discards the result
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.StringOutputProcessor">
            <summary>
            Aggregates multiple string entries into one result, excluding null entries.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.StringListOutputProcessor">
            <summary>
            Aggregates multiple string entries into a list of string result, excluding null entries.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.IProcessManager">
            <summary>
            A process manager that configures processes for running and keeps track of running processes.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.IProcessManager.Configure``1(``0,System.String)">
            <summary>
            Helper that configures all the necessary parts in order to run a process. This must be called before running
            a ProcessTask.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.IProcessManager.Configure``1(``0,System.Diagnostics.ProcessStartInfo)">
            <summary>
            Helper that configures all the necessary parts in order to run a process. This must be called before running
            a ProcessTask.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="processTask"></param>
            <param name="startInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.IProcessManager.WrapProcess(System.String,System.Diagnostics.ProcessStartInfo,Unity.Editor.Tasks.IOutputProcessor,System.Action,System.Action,System.Action{System.Exception,System.String},System.Threading.CancellationToken)">
            <summary>
            Helper that creates a process wrapper for the given process information. This is called by
            ProcessTask during the Configure step.
            </summary>
            <param name="taskName"></param>
            <param name="process"></param>
            <param name="outputProcessor"></param>
            <param name="onStart"></param>
            <param name="onEnd"></param>
            <param name="onError"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Unity.Editor.Tasks.IProcessManager.Stop">
            <summary>
            Stops all running processes managed by this manager.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.IProcessManager.DefaultProcessEnvironment">
            <summary>
            Default process environment.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ProcessManager">
            <summary>
            A process manager that configures processes for running and keeps track of running processes.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessManager.#ctor(Unity.Editor.Tasks.IEnvironment)">
            <summary>
            Creates an instance of the process manager and the <see cref="P:Unity.Editor.Tasks.ProcessManager.DefaultProcessEnvironment"/>.
            </summary>
            <param name="environment"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.Diagnostics.ProcessStartInfo)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessManager.WrapProcess(System.String,System.Diagnostics.ProcessStartInfo,Unity.Editor.Tasks.IOutputProcessor,System.Action,System.Action,System.Action{System.Exception,System.String},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessManager.Stop">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessManager.Dispose(System.Boolean)">
            <summary>
            Stop and clean up managed processes
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessManager.Dispose">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ProcessManager.DefaultProcessEnvironment">
            <inheritdoc />
        </member>
        <member name="T:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom">
            <summary>
            Provides concurrent and exclusive task schedulers that coordinate to execute
            tasks while ensuring that concurrent tasks may run concurrently and exclusive tasks never do.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.m_threadProcessingMapping">
            <summary>A dictionary mapping thread ID to a processing mode to denote what kinds of tasks are currently being processed on this thread.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.m_concurrentTaskScheduler">
            <summary>The scheduler used to queue and execute "concurrent" tasks that may run concurrently with other concurrent tasks.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.m_exclusiveTaskScheduler">
            <summary>The scheduler used to queue and execute "exclusive" tasks that must run exclusively while no other tasks for this pair are running.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.m_underlyingTaskScheduler">
            <summary>The underlying task scheduler to which all work should be scheduled.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.m_maxConcurrencyLevel">
            <summary>
            The maximum number of tasks allowed to run concurrently.  This only applies to concurrent tasks,
            since exlusive tasks are inherently limited to 1.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.m_maxItemsPerTask">
            <summary>The maximum number of tasks we can process before recyling our runner tasks.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.m_processingCount">
            <summary>
            If positive, it represents the number of concurrently running concurrent tasks.
            If negative, it means an exclusive task has been scheduled.
            If 0, nothing has been scheduled.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.m_completionState">
            <summary>Completion state for a task representing the completion of this pair.</summary>
            <remarks>Lazily-initialized only if the scheduler pair is shutting down or if the Completion is requested.</remarks>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.UNLIMITED_PROCESSING">
            <summary>A constant value used to signal unlimited processing.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.EXCLUSIVE_PROCESSING_SENTINEL">
            <summary>Constant used for m_processingCount to indicate that an exclusive task is being processed.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.DEFAULT_MAXITEMSPERTASK">
            <summary>Default MaxItemsPerTask to use for processing if none is specified.</summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.DefaultMaxConcurrencyLevel">
            <summary>Default MaxConcurrencyLevel is the processor count if not otherwise specified.</summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ValueLock">
            <summary>Gets the sync obj used to protect all state on this instance.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.#ctor(System.Threading.CancellationToken)">
            <summary>
            Initializes the ConcurrentExclusiveSchedulerCustom.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler,System.Int32,System.Int32)">
            <summary>
            Initializes the ConcurrentExclusiveSchedulerCustom to target the specified scheduler with a maximum
            concurrency level and a maximum number of scheduled tasks that may be processed as a unit.
            </summary>
            <param name="token"></param>
            <param name="taskScheduler">The target scheduler on which this pair should execute.</param>
            <param name="maxConcurrencyLevel">The maximum number of tasks to run concurrently.</param>
            <param name="maxItemsPerTask">The maximum number of tasks to process for each underlying scheduled task used by the pair.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.Complete">
            <summary>Informs the scheduler pair that it should not accept any more tasks.</summary>
            <remarks>
            Calling <see cref="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.Complete"/> is optional, and it's only necessary if the <see cref="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.Completion"/>
            will be relied on for notification of all processing being completed.
            </remarks>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.Completion">
            <summary>Gets a <see cref="T:System.Threading.Tasks.Task"/> that will complete when the scheduler has completed processing.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.EnsureCompletionStateInitialized">
            <summary>Gets the lazily-initialized completion state.</summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.CompletionRequested">
            <summary>Gets whether completion has been requested.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.RequestCompletion">
            <summary>Sets that completion has been requested.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.CleanupStateIfCompletingAndQuiesced">
            <summary>
            Cleans up state if and only if there's no processing currently happening
            and no more to be done later.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ReadyToComplete">
            <summary>Gets whether the pair is ready to complete.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.CompleteTaskAsync">
            <summary>Completes the completion task asynchronously.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.FaultWithTask(System.Threading.Tasks.Task)">
            <summary>Initiatites scheduler shutdown due to a worker task faulting..</summary>
            <param name="faultedTask">The faulted worker task that's initiating the shutdown.</param>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentScheduler">
            <summary>
            Gets a TaskScheduler that can be used to schedule tasks to this pair
            that may run concurrently with other tasks on this pair.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ExclusiveScheduler">
            <summary>
            Gets a TaskScheduler that can be used to schedule tasks to this pair
            that must run exclusively with regards to other tasks on this pair.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentTaskCountForDebugger">
            <summary>Gets the number of tasks waiting to run concurrently.</summary>
            <remarks>This does not take the necessary lock, as it's only called from under the debugger.</remarks>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ExclusiveTaskCountForDebugger">
            <summary>Gets the number of tasks waiting to run exclusively.</summary>
            <remarks>This does not take the necessary lock, as it's only called from under the debugger.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ProcessAsyncIfNecessary(System.Boolean)">
            <summary>Notifies the pair that new work has arrived to be processed.</summary>
            <param name="fairly">Whether tasks should be scheduled fairly with regards to other tasks.</param>
            <remarks>Must only be called while holding the lock.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ProcessExclusiveTasks">
            <summary>
            Processes exclusive tasks serially until either there are no more to process
            or we've reached our user-specified maximum limit.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ProcessConcurrentTasks">
            <summary>
            Processes concurrent tasks serially until either there are no more to process,
            we've reached our user-specified maximum limit, or exclusive tasks have arrived.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.CompletionState">
            <summary>
            Holder for lazily-initialized state about the completion of a scheduler pair.
            Completion is only triggered either by rare exceptional conditions or by
            the user calling Complete, and as such we only lazily initialize this
            state in one of those conditions or if the user explicitly asks for
            the Completion.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.CompletionState.m_completionQueued">
            <summary>Whether completion processing has been queued.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.CompletionState.m_completionRequested">
            <summary>Whether the scheduler has had completion requested.</summary>
            <remarks>This variable is not volatile, so to gurantee safe reading reads, Volatile.Read is used in TryExecuteTaskInline.</remarks>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.CompletionState.m_exceptions">
            <summary>Unrecoverable exceptions incurred while processing.</summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler">
            <summary>
            A scheduler shim used to queue tasks to the pair and execute those tasks on request of the pair.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.s_tryExecuteTaskShim">
            <summary>Cached delegate for invoking TryExecuteTaskShim.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.m_maxConcurrencyLevel">
            <summary>The maximum concurrency level for the scheduler.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.m_pair">
            <summary>The parent pair.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.m_processingMode">
            <summary>The processing mode of this scheduler, exclusive or concurrent.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.m_tasks">
            <summary>Gets the queue of tasks for this scheduler.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.#ctor(Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom,System.Int32,Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ProcessingMode)">
            <summary>Initializes the scheduler.</summary>
            <param name="pair">The parent pair.</param>
            <param name="maxConcurrencyLevel">The maximum degree of concurrency this scheduler may use.</param>
            <param name="processingMode">The processing mode of this scheduler.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.ExecuteTask(System.Threading.Tasks.Task)">
            <summary>Executes a task on this scheduler.</summary>
            <param name="task">The task to be executed.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a task to the scheduler.</summary>
            <param name="task">The task to be queued.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Tries to execute the task synchronously on this scheduler.</summary>
            <param name="task">The task to execute.</param>
            <param name="taskWasPreviouslyQueued">Whether the task was previously queued to the scheduler.</param>
            <returns>true if the task could be executed; otherwise, false.</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.GetScheduledTasks">
            <summary>Gets for debugging purposes the tasks scheduled to this scheduler.</summary>
            <returns>An enumerable of the tasks queued.</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.TryExecuteTaskInlineOnTargetScheduler(System.Threading.Tasks.Task)">
            <summary>
            Implements a reasonable approximation for TryExecuteTaskInline on the underlying scheduler,
            which we can't call directly on the underlying scheduler.
            </summary>
            <param name="task">The task to execute inline if possible.</param>
            <returns>true if the task was inlined successfully; otherwise, false.</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.TryExecuteTaskShim(System.Object)">
            <summary>Shim used to invoke this.TryExecuteTask(task).</summary>
            <param name="state">A tuple of the ConcurrentExclusiveTaskScheduler and the task to execute.</param>
            <returns>true if the task was successfully inlined; otherwise, false.</returns>
            <remarks>
            This method is separated out not because of performance reasons but so that
            the SecuritySafeCritical attribute may be employed.
            </remarks>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level this scheduler is able to support.</summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.CountForDebugger">
            <summary>Gets the number of tasks queued to this scheduler.</summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.DebugView">
            <summary>Provides a debug view for ConcurrentExclusiveTaskScheduler.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.DebugView.m_taskScheduler">
            <summary>The scheduler being debugged.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.DebugView.#ctor(Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler)">
            <summary>Initializes the debug view.</summary>
            <param name="scheduler">The scheduler being debugged.</param>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.DebugView.MaximumConcurrencyLevel">
            <summary>Gets this pair's maximum allowed concurrency level.</summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.DebugView.ScheduledTasks">
            <summary>Gets the tasks scheduled to this scheduler.</summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ConcurrentExclusiveTaskScheduler.DebugView.SchedulerPair">
            <summary>Gets the scheduler pair with which this scheduler is associated.</summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.DebugView">
            <summary>Provides a debug view for ConcurrentExclusiveSchedulerCustom.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.DebugView.m_pair">
            <summary>The pair being debugged.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.DebugView.#ctor(Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom)">
            <summary>Initializes the debug view.</summary>
            <param name="pair">The pair being debugged.</param>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.DebugView.Mode">
            <summary>Gets a representation of the execution state of the pair.</summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.DebugView.ScheduledExclusive">
            <summary>Gets the number of tasks waiting to run exclusively.</summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.DebugView.ScheduledConcurrent">
            <summary>Gets the number of tasks waiting to run concurrently.</summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.DebugView.CurrentlyExecutingTaskCount">
            <summary>Gets the number of tasks currently being executed.</summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.DebugView.TargetScheduler">
            <summary>Gets the underlying task scheduler that actually executes the tasks.</summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ModeForDebugger">
            <summary>Gets an enumeration for debugging that represents the current state of the scheduler pair.</summary>
            <remarks>This is only for debugging.  It does not take the necessary locks to be useful for runtime usage.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ContractAssertMonitorStatus(System.Object,System.Boolean)">
            <summary>Asserts that a given synchronization object is either held or not held.</summary>
            <param name="syncObj">The monitor to check.</param>
            <param name="held">Whether we want to assert that it's currently held or not held.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.GetCreationOptionsForTask(System.Boolean)">
            <summary>Gets the options to use for tasks.</summary>
            <param name="isReplacementReplica">If this task is being created to replace another.</param>
            <remarks>
            These options should be used for all tasks that have the potential to run user code or
            that are repeatedly spawned and thus need a modicum of fair treatment.
            </remarks>
            <returns>The options to use.</returns>
        </member>
        <member name="T:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ProcessingMode">
            <summary>Provides an enumeration that represents the current state of the scheduler pair.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ProcessingMode.NotCurrentlyProcessing">
            <summary>The scheduler pair is currently dormant, with no work scheduled.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ProcessingMode.ProcessingExclusiveTask">
            <summary>The scheduler pair has queued processing for exclusive tasks.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ProcessingMode.ProcessingConcurrentTasks">
            <summary>The scheduler pair has queued processing for concurrent tasks.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ProcessingMode.Completing">
            <summary>Completion has been requested.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.ProcessingMode.Completed">
            <summary>The scheduler pair is finished processing.</summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.IProducerConsumerQueue`1">
            <summary>Represents a producer/consumer queue used internally by dataflow blocks.</summary>
            <typeparam name="T">Specifies the type of data contained in the queue.</typeparam>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.IProducerConsumerQueue`1.Enqueue(`0)">
            <summary>Enqueues an item into the queue.</summary>
            <param name="item">The item to enqueue.</param>
            <remarks>This method is meant to be thread-safe subject to the particular nature of the implementation.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.IProducerConsumerQueue`1.TryDequeue(`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
            <remarks>This method is meant to be thread-safe subject to the particular nature of the implementation.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.IProducerConsumerQueue`1.GetCountSafe(System.Object)">
            <summary>A thread-safe way to get the number of items in the collection. May synchronize access by locking the provided synchronization object.</summary>
            <param name="syncObj">The sync object used to lock</param>
            <returns>The collection count</returns>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.IProducerConsumerQueue`1.IsEmpty">
            <summary>Gets whether the collection is currently empty.</summary>
            <remarks>This method may or may not be thread-safe.</remarks>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.IProducerConsumerQueue`1.Count">
            <summary>Gets the number of items in the collection.</summary>
            <remarks>In many implementations, this method will not be thread-safe.</remarks>
        </member>
        <member name="T:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.MultiProducerMultiConsumerQueue`1">
            <summary>
            Provides a producer/consumer queue safe to be used by any number of producers and consumers concurrently.
            </summary>
            <typeparam name="T">Specifies the type of data contained in the queue.</typeparam>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.MultiProducerMultiConsumerQueue`1.Unity#Editor#Tasks#ConcurrentExclusiveSchedulerPairCustom#IProducerConsumerQueue{T}#Enqueue(`0)">
            <summary>Enqueues an item into the queue.</summary>
            <param name="item">The item to enqueue.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.MultiProducerMultiConsumerQueue`1.Unity#Editor#Tasks#ConcurrentExclusiveSchedulerPairCustom#IProducerConsumerQueue{T}#TryDequeue(`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.MultiProducerMultiConsumerQueue`1.Unity#Editor#Tasks#ConcurrentExclusiveSchedulerPairCustom#IProducerConsumerQueue{T}#GetCountSafe(System.Object)">
            <summary>A thread-safe way to get the number of items in the collection. May synchronize access by locking the provided synchronization object.</summary>
            <remarks>ConcurrentQueue.Count is thread safe, no need to acquire the lock.</remarks>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.MultiProducerMultiConsumerQueue`1.Unity#Editor#Tasks#ConcurrentExclusiveSchedulerPairCustom#IProducerConsumerQueue{T}#IsEmpty">
            <summary>Gets whether the collection is currently empty.</summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.MultiProducerMultiConsumerQueue`1.Unity#Editor#Tasks#ConcurrentExclusiveSchedulerPairCustom#IProducerConsumerQueue{T}#Count">
            <summary>Gets the number of items in the collection.</summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1">
            <summary>
            Provides a producer/consumer queue safe to be used by only one producer and one consumer concurrently.
            </summary>
            <typeparam name="T">Specifies the type of data contained in the queue.</typeparam>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.INIT_SEGMENT_SIZE">
            <summary>The initial size to use for segments (in number of elements).</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.MAX_SEGMENT_SIZE">
            <summary>The maximum size to use for segments (in number of elements).</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.m_head">
            <summary>The head of the linked list of segments.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.m_tail">
            <summary>The tail of the linked list of segments.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.#ctor">
            <summary>Initializes the queue.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.Enqueue(`0)">
            <summary>Enqueues an item into the queue.</summary>
            <param name="item">The item to enqueue.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.TryDequeue(`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.TryPeek(`0@)">
            <summary>Attempts to peek at an item in the queue.</summary>
            <param name="result">The peeked item.</param>
            <returns>true if an item could be peeked; otherwise, false.</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.TryDequeueIf(System.Predicate{`0},`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="predicate">The predicate that must return true for the item to be dequeued.  If null, all items implicitly return true.</param>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.GetEnumerator">
            <summary>Gets an enumerable for the collection.</summary>
            <remarks>WARNING: This should only be used for debugging purposes.  It is not safe to be used concurrently.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.EnqueueSlow(`0,Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue{`0}.Segment@)">
            <summary>Enqueues an item into the queue.</summary>
            <param name="item">The item to enqueue.</param>
            <param name="segment">The segment in which to first attempt to store the item.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.TryDequeueSlow(Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue{`0}.Segment@,`0[]@,`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="array">The array from which the item was dequeued.</param>
            <param name="segment">The segment from which the item was dequeued.</param>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.TryPeekSlow(Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue{`0}.Segment@,`0[]@,`0@)">
            <summary>Attempts to peek at an item in the queue.</summary>
            <param name="array">The array from which the item is peeked.</param>
            <param name="segment">The segment from which the item is peeked.</param>
            <param name="result">The peeked item.</param>
            <returns>true if an item could be peeked; otherwise, false.</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.TryDequeueIfSlow(System.Predicate{`0},Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue{`0}.Segment@,`0[]@,`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="predicate">The predicate that must return true for the item to be dequeued.  If null, all items implicitly return true.</param>
            <param name="array">The array from which the item was dequeued.</param>
            <param name="segment">The segment from which the item was dequeued.</param>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Gets an enumerable for the collection.</summary>
            <remarks>WARNING: This should only be used for debugging purposes.  It is not safe to be used concurrently.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.Unity#Editor#Tasks#ConcurrentExclusiveSchedulerPairCustom#IProducerConsumerQueue{T}#GetCountSafe(System.Object)">
            <summary>A thread-safe way to get the number of items in the collection. May synchronize access by locking the provided synchronization object.</summary>
            <remarks>The Count is not thread safe, so we need to acquire the lock.</remarks>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.IsEmpty">
            <summary>Gets whether the collection is currently empty.</summary>
            <remarks>WARNING: This should not be used concurrently without further vetting.</remarks>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.Count">
            <summary>Gets the number of items in the collection.</summary>
            <remarks>WARNING: This should only be used for debugging purposes.  It is not meant to be used concurrently.</remarks>
        </member>
        <member name="T:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.Segment">
            <summary>A segment in the queue containing one or more items.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.Segment.m_array">
            <summary>The data stored in this segment.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.Segment.m_next">
            <summary>The next segment in the linked list of segments.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.Segment.m_state">
            <summary>Details about the segment.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.Segment.#ctor(System.Int32)">
            <summary>Initializes the segment.</summary>
            <param name="size">The size to use for this segment.</param>
        </member>
        <member name="T:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.SegmentState">
            <summary>Stores information about a segment.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.SegmentState.m_pad0">
            <summary>Padding to reduce false sharing between the segment's array and m_first.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.SegmentState.m_first">
            <summary>The index of the current head in the segment.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.SegmentState.m_lastCopy">
            <summary>A copy of the current tail index.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.SegmentState.m_pad1">
            <summary>Padding to reduce false sharing between the first and last.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.SegmentState.m_firstCopy">
            <summary>A copy of the current head index.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.SegmentState.m_last">
            <summary>The index of the current tail in the segment.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.SegmentState.m_pad2">
            <summary>Padding to reduce false sharing with the last and what's after the segment.</summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.SingleProducerSingleConsumerQueue_DebugView">
            <summary>Debugger type proxy for a SingleProducerSingleConsumerQueue of T.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.SingleProducerSingleConsumerQueue_DebugView.m_queue">
            <summary>The queue being visualized.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.SingleProducerSingleConsumerQueue_DebugView.#ctor(Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue{`0})">
            <summary>Initializes the debug view.</summary>
        </member>
        <member name="P:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.SingleProducerSingleConsumerQueue`1.SingleProducerSingleConsumerQueue_DebugView.Items">
            <summary>Gets the contents of the list.</summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.PaddingHelpers">
            <summary>A placeholder class for common padding constants and eventually routines.</summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.PaddingHelpers.CACHE_LINE_SIZE">
            <summary>A size greater than or equal to the size of the most common CPU cache lines.</summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ConcurrentExclusiveSchedulerPairCustom.PaddingFor32">
            <summary>Padding structure used to minimize false sharing in SingleProducerSingleConsumerQueue{T}.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.IMainThreadSynchronizationContext.Schedule(System.Action)">
            <summary>
            <summary>Queues a delegate for asynchronous execution.</summary>
            </summary>
            <param name="action">The delegate to execute.</param>
        </member>
        <member name="T:Unity.Editor.Tasks.SynchronizationContextTaskScheduler">
            <summary>Provides a task scheduler that targets a specific SynchronizationContext.</summary>
        </member>
        <member name="P:Unity.Editor.Tasks.SynchronizationContextTaskScheduler.Context">
            <summary>The target context under which to execute the queued tasks.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.SynchronizationContextTaskScheduler.#ctor">
            <summary>Initializes an instance of the SynchronizationContextTaskScheduler class.</summary>
        </member>
        <member name="M:Unity.Editor.Tasks.SynchronizationContextTaskScheduler.#ctor(System.Threading.SynchronizationContext)">
            <summary>
            Initializes an instance of the SynchronizationContextTaskScheduler class
            with the specified SynchronizationContext.
            </summary>
            <param name="context">The SynchronizationContext under which to execute tasks.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.SynchronizationContextTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a task to the scheduler for execution.</summary>
            <param name="task">The Task to queue.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.SynchronizationContextTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Tries to execute a task on the current thread.</summary>
            <param name="task">The task to be executed.</param>
            <param name="taskWasPreviouslyQueued">Ignored.</param>
            <returns>Whether the task could be executed.</returns>
        </member>
        <member name="P:Unity.Editor.Tasks.SynchronizationContextTaskScheduler.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level supported by this scheduler.</summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ThreadingHelper.TaskSchedulerAwaitable">
            <summary>
            An awaitable that executes continuations on the specified task scheduler.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ThreadingHelper.TaskSchedulerAwaitable.taskScheduler">
            <summary>
            The scheduler for continuations.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.TaskSchedulerAwaitable.#ctor(System.Threading.Tasks.TaskScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:Unity.Editor.Tasks.ThreadingHelper.TaskSchedulerAwaitable"/> struct.
            </summary>
            <param name="taskScheduler">The task scheduler used to execute continuations.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.TaskSchedulerAwaitable.GetAwaiter">
            <summary>
            Gets an awaitable that schedules continuations on the specified scheduler.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ThreadingHelper.TaskSchedulerAwaiter">
            <summary>
            An awaiter returned from GetAwaiter(TaskScheduler />.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ThreadingHelper.TaskSchedulerAwaiter.scheduler">
            <summary>
            The scheduler for continuations.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.TaskSchedulerAwaiter.#ctor(System.Threading.Tasks.TaskScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:Unity.Editor.Tasks.ThreadingHelper.TaskSchedulerAwaiter"/> struct.
            </summary>
            <param name="scheduler">The scheduler for continuations.</param>
        </member>
        <member name="P:Unity.Editor.Tasks.ThreadingHelper.TaskSchedulerAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether no yield is necessary.
            </summary>
            <value><c>true</c> if the caller is already running on that TaskScheduler.</value>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.TaskSchedulerAwaiter.OnCompleted(System.Action)">
            <summary>
            Schedules a continuation to execute using the specified task scheduler.
            </summary>
            <param name="continuation">The delegate to invoke.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.TaskSchedulerAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>
            Schedules a continuation to execute using the specified task scheduler
            without capturing the ExecutionContext.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.TaskSchedulerAwaiter.GetResult">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaitable">
            <summary>
            A Task awaitable that has affinity to executing callbacks synchronously on the completing callstack.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaitable.antecedent">
            <summary>
            The task whose completion will execute the continuation.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaitable.#ctor(System.Threading.Tasks.Task)">
            <summary>
            Initializes a new instance of the <see cref="T:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaitable"/> struct.
            </summary>
            <param name="antecedent">The task whose completion will execute the continuation.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaitable.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
            <returns>The awaiter.</returns>
        </member>
        <member name="T:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaiter">
            <summary>
            A Task awaiter that has affinity to executing callbacks synchronously on the completing callstack.
            </summary>
        </member>
        <member name="F:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaiter.antecedent">
            <summary>
            The task whose completion will execute the continuation.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaiter.#ctor(System.Threading.Tasks.Task)">
            <summary>
            Initializes a new instance of the <see cref="T:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaiter"/> struct.
            </summary>
            <param name="antecedent">The task whose completion will execute the continuation.</param>
        </member>
        <member name="P:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the antedent <see cref="T:System.Threading.Tasks.Task"/> has already completed.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaiter.GetResult">
            <summary>
            Rethrows any exception thrown by the antecedent.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaiter.OnCompleted(System.Action)">
            <summary>
            Schedules a callback to run when the antecedent task completes.
            </summary>
            <param name="continuation">The callback to invoke.</param>
        </member>
        <member name="T:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaitable`1">
            <summary>
            A Task awaitable that has affinity to executing callbacks synchronously on the completing callstack.
            </summary>
            <typeparam name="T">The type of value returned by the awaited <see cref="T:System.Threading.Tasks.Task"/>.</typeparam>
        </member>
        <member name="F:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaitable`1.antecedent">
            <summary>
            The task whose completion will execute the continuation.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaitable`1.#ctor(System.Threading.Tasks.Task{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaitable`1"/> struct.
            </summary>
            <param name="antecedent">The task whose completion will execute the continuation.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaitable`1.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
            <returns>The awaiter.</returns>
        </member>
        <member name="T:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaiter`1">
            <summary>
            A Task awaiter that has affinity to executing callbacks synchronously on the completing callstack.
            </summary>
            <typeparam name="T">The type of value returned by the awaited <see cref="T:System.Threading.Tasks.Task"/>.</typeparam>
        </member>
        <member name="F:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaiter`1.antecedent">
            <summary>
            The task whose completion will execute the continuation.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaiter`1.#ctor(System.Threading.Tasks.Task{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaiter`1"/> struct.
            </summary>
            <param name="antecedent">The task whose completion will execute the continuation.</param>
        </member>
        <member name="P:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaiter`1.IsCompleted">
            <summary>
            Gets a value indicating whether the antedent <see cref="T:System.Threading.Tasks.Task"/> has already completed.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaiter`1.GetResult">
            <summary>
            Rethrows any exception thrown by the antecedent.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ThreadingHelper.ExecuteContinuationSynchronouslyAwaiter`1.OnCompleted(System.Action)">
            <summary>
            Schedules a callback to run when the antecedent task completes.
            </summary>
            <param name="continuation">The callback to invoke.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.BaseProcessTask.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.String,System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="T:Unity.Editor.Tasks.BaseProcessTask`1">
            <summary>
            Runs a process.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.BaseProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.BaseProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0},System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="T:Unity.Editor.Tasks.BaseProcessListTask`1">
            <summary>
            Runs a process.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.BaseProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.BaseProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0,System.Collections.Generic.List{`0}},System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="T:Unity.Editor.Tasks.IProcess">
            <summary>
            An external process managed by the <see cref="T:Unity.Editor.Tasks.IProcessManager" /> and
            wrapped by a <see cref="T:Unity.Editor.Tasks.IProcessTask" />
            </summary>
        </member>
        <member name="E:Unity.Editor.Tasks.IProcess.OnEndProcess">
            <summary>
            Event raised when the process exits
            </summary>
        </member>
        <member name="E:Unity.Editor.Tasks.IProcess.OnErrorData">
            <summary>
            Event raised after the process is finished, with any output that the process sent to stderr.
            </summary>
        </member>
        <member name="E:Unity.Editor.Tasks.IProcess.OnStartProcess">
            <summary>
            Event raised when the process is started.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.IProcess.Stop">
            <summary>
            Stops the process.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.IProcess.StandardInput">
            <summary>
            The StandardInput of the process is redirected to this stream writer.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.IProcess.ProcessId">
            <summary>
            The underlying process id.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.IProcess.ProcessName">
            <summary>
            The process name.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.IProcess.ProcessArguments">
            <summary>
            The process arguments.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.IProcess.Wrapper">
            <summary>
            The underlying process object.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.IProcessTask">
            <summary>
            A task that runs an external process.
            </summary>
        </member>
        <member name="P:Unity.Editor.Tasks.IProcessTask.ProcessEnvironment">
            <summary>
            The environment for the process. This is a wrapper of <see cref="T:Unity.Editor.Tasks.IEnvironment" /> that also includes a working directory,
            and configures environment variables of the process.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.IProcessTask.Configure(Unity.Editor.Tasks.IProcessManager,System.Diagnostics.ProcessStartInfo)">
            <summary>
            Configures the underlying process object.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.IProcessTask.Start">
            <summary>
            An overloaded <see cref="M:Unity.Editor.Tasks.ITask.Start" /> method that returns IProcessTask, to make it easier to chain.
            </summary>
            <returns>The started task.</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.IProcessTask.Start(System.Threading.Tasks.TaskScheduler)">
            <summary>
            An overloaded <see cref="M:Unity.Editor.Tasks.ITask.Start(System.Threading.Tasks.TaskScheduler)" /> method that returns IProcessTask, to make it easier to chain.
            </summary>
            <returns>The started task.</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.IProcessTask.Detach">
            <summary>
            If you call this on a running process task, it will trigger the task to finish, raising
            OnEnd and OnEndProcess, without stopping the underlying process. Process manager won't
            stop a released process on shutdown. This will effectively leak the process, but if you
            need to run a background process that won't be stopped if the domain goes down, call this.
            </summary>
        </member>
        <member name="T:Unity.Editor.Tasks.IProcessTask`1">
            <summary>
            A task that runs an external process and returns the process output.
            </summary>
            <typeparam name="T">The output of the process, processed via an IOutputProcessor.</typeparam>
        </member>
        <member name="M:Unity.Editor.Tasks.IProcessTask`1.Configure(Unity.Editor.Tasks.IProcessManager,System.Diagnostics.ProcessStartInfo,Unity.Editor.Tasks.IOutputProcessor{`0})">
            <summary>
            Set the underlying process object,
            and optionally sets an output processor, if one wasn't set in the constructor or set in some
            other way. The process manager is responsible for creating and configuring the process object.
            </summary>
            <param name="processManager"></param>
            <param name="startInfo"></param>
            <param name="processor">The output processor to use to process the process output.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.IProcessTask`1.Start">
            <summary>
            An overloaded <see cref="M:Unity.Editor.Tasks.ITask.Start" /> method that returns IProcessTask, to make it easier to chain.
            </summary>
            <returns>The started task.</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.IProcessTask`1.Start(System.Threading.Tasks.TaskScheduler)">
            <summary>
            An overloaded <see cref="M:Unity.Editor.Tasks.ITask.Start(System.Threading.Tasks.TaskScheduler)" /> method that returns IProcessTask, to make it easier to chain.
            </summary>
            <returns>The started task.</returns>
        </member>
        <member name="E:Unity.Editor.Tasks.IProcessTask`1.OnOutput">
            <inheritdoc />
        </member>
        <member name="T:Unity.Editor.Tasks.IProcessTask`2">
            <summary>
            A task that runs an external process and returns the process output, converting it in the process to
            a different type. This is mainly for creating lists of data, where <typeparamref name="TData"/> is
            the type of a single item, and <typeparamref name="T" /> is a List&lt;TData&gt;.
            The base <see cref="T:Unity.Editor.Tasks.ITask`2" /> provides a <see cref="E:Unity.Editor.Tasks.ITask`2.OnData" />
            event that is called whenever the output processor raised the OnEntry event.
            </summary>
            <typeparam name="TData"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Unity.Editor.Tasks.IProcessTask`2.Configure(Unity.Editor.Tasks.IProcessManager,System.Diagnostics.ProcessStartInfo,Unity.Editor.Tasks.IOutputProcessor{`0,`1})">
            <summary>
            Set the underlying process object,
            and optionally sets an output processor, if one wasn't set in the constructor or set in some
            other way. The process manager is responsible for creating and configuring the process object.
            </summary>
            <param name="processManager"></param>
            <param name="startInfo"></param>
            <param name="processor">The output processor to use to process the process output.</param>
        </member>
        <member name="M:Unity.Editor.Tasks.IProcessTask`2.Start">
            <summary>
            An overloaded <see cref="M:Unity.Editor.Tasks.ITask.Start" /> method that returns IProcessTask, to make it easier to chain.
            </summary>
            <returns>The started task.</returns>
        </member>
        <member name="M:Unity.Editor.Tasks.IProcessTask`2.Start(System.Threading.Tasks.TaskScheduler)">
            <summary>
            An overloaded <see cref="M:Unity.Editor.Tasks.ITask.Start(System.Threading.Tasks.TaskScheduler)" /> method that returns IProcessTask, to make it easier to chain.
            </summary>
            <returns>The started task.</returns>
        </member>
        <member name="T:Unity.Editor.Tasks.ProcessTask`1">
            <summary>
            A task that runs an external process and returns the process output.
            </summary>
            <typeparam name="T">The output of the process, processed via an IOutputProcessor.</typeparam>
        </member>
        <member name="E:Unity.Editor.Tasks.ProcessTask`1.OnEndProcess">
            <inheritdoc />
        </member>
        <member name="E:Unity.Editor.Tasks.ProcessTask`1.OnErrorData">
            <inheritdoc />
        </member>
        <member name="E:Unity.Editor.Tasks.ProcessTask`1.OnStartProcess">
            <inheritdoc />
        </member>
        <member name="E:Unity.Editor.Tasks.ProcessTask`1.OnOutput">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0},System.Threading.CancellationToken)">
            <summary>
            Runs a Process with the passed arguments
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTask`1.Configure(Unity.Editor.Tasks.IProcessManager,System.Diagnostics.ProcessStartInfo,Unity.Editor.Tasks.IOutputProcessor{`0})">
            <summary>
            Set the underlying process object,
            and optionally sets an output processor, if one wasn't set in the constructor or set in some
            other way. The process manager is responsible for creating and configuring the process object via
            a call to <see cref="M:Unity.Editor.Tasks.IProcessManager.WrapProcess(System.String,System.Diagnostics.ProcessStartInfo,Unity.Editor.Tasks.IOutputProcessor,System.Action,System.Action,System.Action{System.Exception,System.String},System.Threading.CancellationToken)" />.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTask`1.Unity#Editor#Tasks#IProcessTask#Configure(Unity.Editor.Tasks.IProcessManager,System.Diagnostics.ProcessStartInfo)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTask`1.Start">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTask`1.Start(System.Threading.Tasks.TaskScheduler)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTask`1.Unity#Editor#Tasks#IProcessTask#Start">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTask`1.Unity#Editor#Tasks#IProcessTask#Start(System.Threading.Tasks.TaskScheduler)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTask`1.Stop">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTask`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTask`1.RaiseOnStartProcess">
            <summary>
            Called when the process has been started.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTask`1.RaiseOnEndProcess">
            <summary>
            Call after OnEnd, when the process has finished.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTask`1.ConfigureOutputProcessor">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTask`1.RunWithReturn(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTask`1.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTask`1.Dispose">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ProcessTask`1.ProcessEnvironment">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ProcessTask`1.ProcessId">
            <inheritdoc />
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ProcessTask`1.Successful">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ProcessTask`1.StandardInput">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ProcessTask`1.ProcessName">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ProcessTask`1.ProcessArguments">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ProcessTask`1.OutputProcessor">
            <inheritdoc />
        </member>
        <member name="T:Unity.Editor.Tasks.ProcessTaskWithListOutput`1">
            <summary>
            A helper process task that returns a list of data from the output of the process.
            </summary>
            <typeparam name="T">The type of the items on the returned list.</typeparam>
        </member>
        <member name="E:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.OnEndProcess">
            <inheritdoc />
        </member>
        <member name="E:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.OnErrorData">
            <inheritdoc />
        </member>
        <member name="E:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.OnStartProcess">
            <inheritdoc />
        </member>
        <member name="E:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.OnOutput">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0,System.Collections.Generic.List{`0}},System.Threading.CancellationToken)">
            <summary>
            Runs a Process with the passed arguments
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
            <param name="processEnvironment"></param>
            <param name="executable"></param>
            <param name="arguments"></param>
            <param name="outputProcessor"></param>
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.Configure(Unity.Editor.Tasks.IProcessManager,System.Diagnostics.ProcessStartInfo,Unity.Editor.Tasks.IOutputProcessor{`0,System.Collections.Generic.List{`0}})">
            <summary>
            Set the underlying process object,
            and optionally sets an output processor, if one wasn't set in the constructor or set in some
            other way. The process manager is responsible for creating and configuring the process object via
            a call to <see cref="M:Unity.Editor.Tasks.IProcessManager.WrapProcess(System.String,System.Diagnostics.ProcessStartInfo,Unity.Editor.Tasks.IOutputProcessor,System.Action,System.Action,System.Action{System.Exception,System.String},System.Threading.CancellationToken)" />.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.Unity#Editor#Tasks#IProcessTask#Configure(Unity.Editor.Tasks.IProcessManager,System.Diagnostics.ProcessStartInfo)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.Start">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.Start(System.Threading.Tasks.TaskScheduler)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.Stop">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.Detach">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.RaiseOnStartProcess">
            <summary>
            Called when the process has been started.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.RaiseOnEndProcess">
            <summary>
            Call after OnEnd, when the process has finished.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.ConfigureOutputProcessor">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.RunWithReturn(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.Dispose">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.ProcessEnvironment">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.ProcessId">
            <inheritdoc />
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.Successful">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.StandardInput">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.ProcessName">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.ProcessArguments">
            <inheritdoc />
        </member>
        <member name="P:Unity.Editor.Tasks.ProcessTaskWithListOutput`1.OutputProcessor">
            <inheritdoc />
        </member>
        <member name="T:Unity.Editor.Tasks.DotNetProcessTask">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IEnvironment,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="T:Unity.Editor.Tasks.DotNetProcessTask`1">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0},System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0},System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="T:Unity.Editor.Tasks.DotNetProcessListTask`1">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0,System.Collections.Generic.List{`0}},System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0,System.Collections.Generic.List{`0}},System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0,System.Collections.Generic.List{`0}},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0,System.Collections.Generic.List{`0}},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DotNetProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a dotnet process. On Windows, it just runs the executable. On non-Windows,
            it runs the executable using Unity's mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.DownloadTask.RunDownload(System.Boolean)">
            <summary>
            The actual functionality to download with optional hash verification
            subclasses that wish to return the contents of the downloaded file
            or do something else with it can override this instead of RunWithReturn.
            </summary>
            <param name="success"></param>
            <returns></returns>
        </member>
        <member name="E:Unity.Editor.Tasks.Downloader.OnDownloadComplete">
            <summary>
            Called for every queued download task when it finishes.
            </summary>
        </member>
        <member name="E:Unity.Editor.Tasks.Downloader.OnDownloadFailed">
            <summary>
            Called for every queued download task when it fails.
            </summary>
        </member>
        <member name="E:Unity.Editor.Tasks.Downloader.OnDownloadStart">
            <summary>
            Called for every queued download task when it starts.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.Downloader.#ctor(Unity.Editor.Tasks.ITaskManager,System.Threading.CancellationToken)">
            <summary>
            TaskQueue of DownloaderTask objects that can download multiple
            things in parallel.
            </summary>
            <param name="taskManager"></param>
            <param name="token"></param>
        </member>
        <member name="T:Unity.Editor.Tasks.MonoProcessTask">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IEnvironment,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="T:Unity.Editor.Tasks.MonoProcessTask`1">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="T:Unity.Editor.Tasks.MonoProcessListTask`1">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0,System.Collections.Generic.List{`0}},System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0,System.Collections.Generic.List{`0}},System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0,System.Collections.Generic.List{`0}},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0,System.Collections.Generic.List{`0}},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.MonoProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process in Unity's Mono.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="T:Unity.Editor.Tasks.NativeProcessTask">
            <summary>
            Runs a process.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="T:Unity.Editor.Tasks.NativeProcessTask`1">
            <summary>
            Runs a process.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="T:Unity.Editor.Tasks.NativeProcessListTask`1">
            <summary>
            Runs a process.
            </summary>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0,System.Collections.Generic.List{`0}},System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0,System.Collections.Generic.List{`0}},System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0,System.Collections.Generic.List{`0}},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,Unity.Editor.Tasks.IOutputProcessor{`0,System.Collections.Generic.List{`0}},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task before running it.</remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,System.Boolean},System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
        <member name="M:Unity.Editor.Tasks.NativeProcessListTask`1.#ctor(Unity.Editor.Tasks.ITaskManager,Unity.Editor.Tasks.IProcessManager,Unity.Editor.Tasks.IProcessEnvironment,System.String,System.String,System.Func{Unity.Editor.Tasks.IProcessTask{`0,System.Collections.Generic.List{`0}},System.String,`0},System.String,System.Threading.CancellationToken)">
            <summary>
            Runs a process.
            </summary>
            <remarks>You don't need to call <see cref="M:Unity.Editor.Tasks.ProcessManager.Configure``1(``0,System.String)"/> on this task,
            it already does it in the constructor.
            </remarks>
        </member>
    </members>
</doc>
